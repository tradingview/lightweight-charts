<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>LOD (Level of Details) Test</title>
	<style>
		body {
			font-family: Arial, sans-serif;
			margin: 20px;
		}

		.info {
			background: #f0f0f0;
			padding: 10px;
			border-radius: 5px;
			margin-bottom: 20px;
		}

		#chart {
			border: 1px solid #ccc;
		}

		.controls {
			margin: 20px 0;
		}

		button {
			margin: 5px;
			padding: 8px 16px;
			cursor: pointer;
		}
	</style>
</head>

<body>
	<h1>Offscreen Worker Test</h1>

	<div class="info">
		<p><strong>Instructions:</strong></p>
		<ul>
			<li>This test generates large datasets: 300k line points, 300k candlestick points, and 300k sparse points
				(80% whitespace)</li>
			<li><strong>Conflation is enabled in this example (false by default)</strong></li>
		</ul>
	</div>

	<div class="controls">
		<button onclick="zoomOut()">Zoom Out (trigger LOD)</button>
		<button onclick="zoomIn()">Zoom In (disable LOD)</button>
		<button onclick="resetChart()">Reset Chart</button>
		<button onclick="addWorkerPlugin()">Add Worker Plugin</button>
		<button onclick="updateWorkerPlugin()">Update Plugin Options</button>
		<button onclick="removeWorkerPlugin()">Remove Worker Plugin</button>
		<button onclick="addVerticalLinePlugin()">Add Vertical Line</button>
		<label style="margin-left:16px">Rendering Engine:
			<select id="renderingEngine" onchange="switchRenderingEngine()">
				<option value="worker" selected>Worker</option>
				<option value="main-thread">Main Thread</option>
			</select>
		</label>
		<label style="margin-left:16px">Transport:
			<select id="transport" onchange="switchTransport()">
				<option value="sab" selected>SharedArrayBuffer</option>
				<option value="ab">ArrayBuffer</option>
				<option value="json">JSON</option>
			</select>
		</label>
	</div>

	<div id="chart"></div>

	<script src="/dist/lightweight-charts.standalone.production.js"></script>
	<!-- <script src="/dist/lightweight-charts.standalone.development.js"></script> -->
	<script>
		let chart;
		let lineSeries;
		let candlestickSeries;
		let whitespaceLineSeries;
		let conflationEnabled = true;
		let transportMode = 'sab';
		let renderingEngine = 'worker';
		let pluginHandle = null;
		let bandsHandle = null;
		let vertLineHandle = null;

		function generateTestData(count = 10000) {
			const data = [];
			const now = Date.now() / 1000;
			let price = 100;

			console.log(`Generating ${count} data points...`);

			for (let i = 0; i < count; i++) {
				// Random walk price generation
				price += (Math.random() - 0.5) * 2;
				price = Math.max(50, Math.min(200, price)); // Keep price in reasonable range

				const time = now - (count - i) * 60; // 1 minute intervals going backwards
				data.push({
					time: time,
					value: Math.round(price * 100) / 100
				});
			}

			console.log('Data generation complete');
			return data;
		}

		function generateCandlestickData(count = 10000) {
			const data = [];
			const now = Date.now() / 1000;
			let price = 100;

			console.log(`Generating ${count} candlestick data points...`);

			for (let i = 0; i < count; i++) {
				const open = price;
				const change = (Math.random() - 0.5) * 4;
				price += change;
				price = Math.max(50, Math.min(200, price));

				const high = Math.max(open, price) + Math.random() * 2;
				const low = Math.min(open, price) - Math.random() * 2;

				const time = now - (count - i) * 60;
				data.push({
					time: time,
					open: Math.round(open * 100) / 100,
					high: Math.round(high * 100) / 100,
					low: Math.round(low * 100) / 100,
					close: Math.round(price * 100) / 100
				});
			}

			console.log('Candlestick data generation complete');
			return data;
		}

		function generateSparseDataWithWhitespace(count = 100000) {
			const data = [];
			const now = Date.now() / 1000;
			let price = 150;

			console.log(`Generating ${count} sparse data points with lots of whitespace...`);

			for (let i = 0; i < count; i++) {
				const time = now - (count - i) * 60;

				if (Math.random() < 0.2) {
					price += (Math.random() - 0.5) * 3;
					price = Math.max(80, Math.min(220, price));

					data.push({
						time: time,
						value: Math.round(price * 100) / 100
					});
				} else {
					// Whitespace data point (no value)
					data.push({
						time: time
						// No value property = whitespace
					});
				}
			}

			console.log('Sparse data generation complete');
			return data;
		}

		const lineData = generateTestData(300000);
		const candlestickData = generateCandlestickData(300000);
		const whitespaceData = generateSparseDataWithWhitespace(300000);
		function createChart() {
			chart = LightweightCharts.createChart(document.getElementById('chart'), {
				width: 1200,
				height: 600,
				renderingEngine: renderingEngine,
				dataTransport: transportMode,
				timeScale: {
					timeVisible: true,
					secondsVisible: false,
					barSpacing: 0.2,
					minBarSpacing: 1200 / window.devicePixelRatio / 300000 / 2, // make all data visible
					// enableConflation: conflationEnabled
				},
				grid: {
					vertLines: { color: '#e1e1e1' },
					horzLines: { color: '#e1e1e1' }
				}
			});

			lineSeries = chart.addSeries(LightweightCharts.LineSeries, {
				color: '#2962FF',
				title: 'Line Series (10k points)',
				lineWidth: 1
			});

			candlestickSeries = chart.addSeries(LightweightCharts.CandlestickSeries, {
				upColor: '#26a69a',
				downColor: '#ef5350',
				borderVisible: false,
				wickUpColor: '#26a69a',
				wickDownColor: '#ef5350',
				title: 'Candlestick Series (300k points)'
			});

			whitespaceLineSeries = chart.addSeries(LightweightCharts.LineSeries, {
				color: '#ff6b6b',
				title: 'Sparse Line with Whitespace (300k points, 80% whitespace)',
				lineWidth: 2
			});

			console.time('setData');
			lineSeries.setData(lineData);
			candlestickSeries.setData(candlestickData);
			whitespaceLineSeries.setData(whitespaceData);
			console.timeEnd('setData');

			chart.timeScale().fitContent();
			// function myVisibleTimeRangeChangeHandler(newVisibleTimeRange) {
			// 	if (newVisibleTimeRange === null) {
			// 		// handle null
			// 	}

			// 	// handle new logical range
			// 	console.log('newVisibleTimeRange', newVisibleTimeRange);
			// }

			// chart.timeScale().subscribeVisibleTimeRangeChange(myVisibleTimeRangeChangeHandler);
			// function myVisibleLogicalRangeChangeHandler(newVisibleLogicalRange) {
			// 	if (newVisibleLogicalRange === null) {
			// 		// handle null
			// 	}

			// 	// handle new logical range
			// 	console.log('newVisibleLogicalRange', newVisibleLogicalRange);
			// }

			// chart.timeScale().subscribeVisibleLogicalRangeChange(myVisibleLogicalRangeChangeHandler);
			// function myClickHandler(param) {
			// 	console.log('myClickHandler', param);
			// 	if (!param.point) {
			// 		return;
			// 	}

			// 	console.log(`Click at ${param.point.x}, ${param.point.y}. The time is ${param.time}.`);
			// }

			// chart.subscribeClick(myClickHandler);
		}

		function addWorkerPlugin() {
			if (renderingEngine !== 'worker') {
				console.warn('Worker plugin demo only works in worker rendering mode');
				return;
			}
			if (pluginHandle) {
				console.warn('Plugin already added');
				return;
			}
			// The plugin file is at /plugin-examples/minimal-worker-plugin.js relative to dev server root
			pluginHandle = chart.addPlugin({
				url: '/plugin-examples/minimal-worker-plugin.js',
				exportName: 'createMinimalWorkerPlugin',
				options: { text: 'Hello from Worker Plugin', color: '#0066ff' },
			});
		}

		function updateWorkerPlugin() {
			if (!pluginHandle) {
				console.warn('No plugin to update. Click "Add Worker Plugin" first.');
				return;
			}
			const colors = ['#0066ff', '#ff0066', '#00aa00', '#aa00aa'];
			const color = colors[(Math.random() * colors.length) | 0];
			pluginHandle.applyOptions({ color, text: `Worker Plugin (${color})` });
		}

		function removeWorkerPlugin() {
			if (!pluginHandle) {
				console.warn('No plugin to remove.');
				return;
			}
			pluginHandle.remove();
			pluginHandle = null;
		}
		function addVerticalLinePlugin() {
			if (renderingEngine !== 'worker') {
				console.warn('Worker plugin demo only works in worker rendering mode');
				return;
			}
			if (vertLineHandle) {
				vertLineHandle.remove();
				vertLineHandle = null;
			}

			const centerTime = lineData[Math.floor(lineData.length / 2)].time;
			vertLineHandle = chart.addPlugin({
				url: '/plugin-examples/vertical-line-worker-plugin.js',
				exportName: 'createVerticalLineWorkerPlugin',
				options: { time: centerTime, showLabel: true, labelText: 'IT WORKS!!!', color: 'green' },
			});
		}

		function zoomOut() {
			console.log('Zooming out to trigger LOD...');
			chart.timeScale().fitContent();
		}

		function zoomIn() {
			console.log('Zooming in to disable LOD...');
			const visibleRange = chart.timeScale().getVisibleLogicalRange();
			if (visibleRange) {
				const center = (visibleRange.from + visibleRange.to) / 2;
				const newRange = 50;
				chart.timeScale().setVisibleLogicalRange({
					from: center - newRange / 2,
					to: center + newRange / 2
				});
			}
		}

		function resetChart() {
			console.log('Resetting chart...');
			chart.timeScale().resetTimeScale();
		}

		function generateMoreData() {
			console.log('Adding more data to stress test LOD...');
			const moreLineData = generateTestData(100000);
			const moreCandlestickData = generateCandlestickData(100000);

			console.time('setData (100k points)');
			lineSeries.setData(moreLineData);
			candlestickSeries.setData(moreCandlestickData);
			console.timeEnd('setData (100k points)');

			chart.timeScale().fitContent();
		}
		function switchRenderingEngine() {
			const sel = document.getElementById('renderingEngine');
			renderingEngine = sel.value;
			if (chart) {
				chart.remove();

				setTimeout(() => {
					document.getElementById('chart').innerHTML = '';
					createChart();
				}, 1000);
			}

		}

		function switchTransport() {
			const sel = document.getElementById('transport');
			transportMode = sel.value;
			if (chart) {
				chart.remove();
			}
			createChart();

		}

		// Initialize chart when page loads
		window.addEventListener('load', () => {
			console.log('Creating chart with LOD implementation...');
			createChart();
		});
	</script>

</body>

</html>
