---
id: advanced-react-example
title: How to wrap Lightweight Charts into parent/children components
sidebar_position: 1
---

:::info

The following describes a more complex scenario where a user could imagine splitting the responsibilities of the chart between components.

If you want to consult a simpler approach please consult this [example](simple-react-example).

:::

:::warning

By following the steps below we assume you're familiar with Lightweight Charts, how to set up a project using it and how to render a chart.

If not, please follow this [guide](./simple-react-example).

:::

If you're familiar with Lightweight Charts you probably already know that a _Chart_ is a container that can contain one or more [_Series_](../series-types.md).
Each _Series_ has its own options (for instance [AreaStyleOptions](/api/interfaces/AreaStyleOptions.md), [LineStyleOptions](/api/interfaces/LineStyleOptions.md), etc) in addition to [price](../price-scale.md) and/or [time](../time-scale.md) scale.

Based on this principle, one could easily imagine having a main component _Chart_ that could have some _Series_ children that could themselves have other children and so on.
Therefore the structure could become something like

```
<Chart component>
	<Series component 1>
		<child component />
	</Series component 1>
	<Series component n>
		<child component />
	</Series component n>
</Chart component>
```

Even though it's possible to create a Chart without a Series, the complexity arises when another component wants to interact with any of its siblings/parent, like updating a series by adding more data or resizing the chart itself.

Given this tutorial is about React this is how we are going to define components relying on React [Hooks](https://reactjs.org/docs/hooks-intro.html) and [composition](https://reactjs.org/docs/composition-vs-inheritance.html).

However, one drawback with the way React and its hooks like _useEffect_ [work](https://github.com/facebook/react/issues/16728) in a parent/children implementation is that their respective hooks are called in a bottom-up order for instanciation but top-to-bottom when it comes to clean-up.

The following skeleton illustrates the mechanism.

```
ParentComponent = () => {
	useEffect(() => {
		// this effect will be triggered in position 3

		return () => {
			// this clean up will be triggered in position 1
		};
	}, []);

	useEffect(() => {
		// this effect will be triggered in position 4

		return () => {
			// this clean up will be triggered in position 2
		};
	}, []);

	// The parent will then return Following bit is to propagate all props & internalRef object down to children
	return (
		<ChildComponent />
	);
}

ChildComponent = () => {
	useEffect(() => {
		// this effect will be triggered in position 1

		return () => {
			// this clean up will be triggered in position 3
		};
	}, []);

	useEffect(() => {
		// this effect will be triggered in position 2

		return () => {
			// this clean up will be triggered in position 4
		};
	}, []);

	return (
		<div />
	);
}
```

In essence, taking the example above, it means that a `ChildComponent` (aka Series) would be created first whilst requiring a `ParentComponent` (aka Chart).

To achieve that, we will have to rely on a few hooks and take advantage of the way they work in addition to use [ref/forwardRef](https://reactjs.org/docs/forwarding-refs.html) which is a technique to pass down properties from one component to its children.

In the end the "visible" structure and usage will be alike but internally it will be something like:

```
<Chart component>
	<ChartContainer>
		<Series component 1>
			<child component />
		</Series component 1>
		<Series component n>
			<child component />
		</Series component n>
	</ChartContainer>
</Chart component>
```

where the ChartContainer's role would be needed to attach a DOMElement on which the chart will render.
ChartContainer will be responsible for creating a **ref**erence that will hold functions to handle the lifecycle of the chart.
That reference will then be propagated down to the Series.

The same technique will be used within the Series component to handle this time the lifecycle of any Series along with adding data to be plotted.

Moreover those 2 "main" components will "expose" whatever functions the user wants from the internal reference object at a higher level, meaning once those references are accessible any other component would then be able to act on either the Chart or any Series.

Here's a squeleton of what the final structure would be like:

```
MainComponent = (props) => {
	// Creates the first reference and instanciate a ParentComponent
	return (
		<div ref={chartReference}>
			<ChartContainer {...props} container={container} />
		</div>
	);
}

ParentComponent = forwardRef(props, ref) => {
	const internalRef = useRef({
		method1() {
			// This function would be responsible for creating the chart for instance
		},
		methodn() {
			// This function would be responsible for cleaning up the chart
		}
	});

	useEffect(() => {
		// this effect will be triggered in position 3

		return () => {
			// this clean up will be triggered in position 1
		};
	}, []);

	useEffect(() => {
		// this effect will be triggered in position 4

		return () => {
			// this clean up will be triggered in position 2
		};
	}, []);

	useImperativeHandle(ref, () => {
		// That's the hook responsible for exposing part of/entirety of internalRef
	}, []);

	// Following bit is to propagate all props & internalRef object down to children
	return (
		<Context.Provider value={internalRef.current}>
			{props.children}
		</Context.Provider>
	);
}

ChildComponent = forwardRef(props, ref) => {
	const internalRef = useRef({
		method1() {
			// This function would be responsible for creating a series
		},
		methodn() {
			// This function would be responsible for removing it
		}
	});

	useEffect(() => {
		// this effect will be triggered in position 1

		return () => {
			// this clean up will be triggered in position 3
		};
	}, []);

	useEffect(() => {
		// this effect will be triggered in position 2

		return () => {
			// this clean up will be triggered in position 4
		};
	}, []);

	useImperativeHandle(ref, () => {
		// That's the hook responsible for exposing part of/entirety of internalRef
	}, []);

	// Following bit is to propagate all props & internalRef object down to children
	return (
		<Context.Provider value={internalRef.current}>
			{props.children}
		</Context.Provider>
	);
}
```

By considering all the above you could end up with Chart/Series components looking like the following

import CodeBlock from '@theme/CodeBlock';
import Code from '!!raw-loader!./../../src/pages/_react/advanced-react-example';

<CodeBlock className="language-jsx">{Code}</CodeBlock>

The code above will produce a Series of type `line` in a 600x400 Chart.
Given a `series1` reference is created to be passed to the Series component you could reuse that object via `series1.current.[any function applicable on Series]`.

For instance and as shown below `series1.current.update(new data)` is used upon clicking on the button.

import { App } from "../../src/pages/_react/advanced-react-example"

<App/>
