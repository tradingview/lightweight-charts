"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4774],{5906:function(t,e,n){n.r(e),n.d(e,{contentTitle:function(){return N},default:function(){return _},frontMatter:function(){return x},metadata:function(){return R},toc:function(){return S}});var r=n(7462),i=n(3366),a=n(7294),o=n(3905),s=n(1736),c=n(3136),l=["children","container"],p=["children","container"],h=["children","container"],u=["children","data","type"],d=["chilren","data"],f=(0,a.createContext)(),m=[{time:"2018-10-11",value:52.89},{time:"2018-10-12",value:51.65},{time:"2018-10-13",value:51.56},{time:"2018-10-14",value:50.19},{time:"2018-10-15",value:51.86},{time:"2018-10-16",value:51.25}],g=new Date(m[m.length-1].time),w=function(){var t=(0,a.useRef)(null),e=(0,a.useState)(!1),n=e[0],r=e[1];return(0,a.useEffect)((function(){if(null!==t.current&&n){var e=setInterval((function(){g.setDate(g.getDate()+1);var e={time:g.toISOString().slice(0,10),value:53-2*Math.random()};t.current.update(e)}),1e3);return function(){return clearInterval(e)}}}),[n]),a.createElement(a.Fragment,null,a.createElement("button",{type:"button",onClick:function(){return r((function(t){return!t}))}},n?"Stop updating":"Start updating series"),a.createElement(v,null,a.createElement(C,{ref:t,type:"line",data:m})))};function v(t){var e=(0,a.useState)(!1),n=e[0],i=e[1],o=(0,a.useCallback)((function(t){return i(t)}),[]);return a.createElement("div",{ref:o},n&&a.createElement(k,(0,r.Z)({},t,{container:n})))}var k=(0,a.forwardRef)((function(t,e){var n=(0,a.useRef)({api:function(){if(!this._api){t.children;var e=t.container,n=(0,i.Z)(t,l);this._api=(0,c.C2)(e,Object.assign({},n,{width:e.clientWidth,height:300})),this._api.timeScale().fitContent()}return this._api},free:function(){this._api&&this._api.remove()}});return(0,a.useLayoutEffect)((function(){t.children;var e=t.container,r=(0,i.Z)(t,p),a=n.current.api(),o=function(){a.applyOptions(Object.assign({},r,{width:e.clientWidth}))};return window.addEventListener("resize",o),function(){window.removeEventListener("resize",o),a.remove()}}),[]),(0,a.useLayoutEffect)((function(){n.current.api()}),[]),(0,a.useLayoutEffect)((function(){var e=n.current,r=(t.children,t.container,(0,i.Z)(t,h));e.api().applyOptions(r)}),[]),(0,a.useImperativeHandle)(e,(function(){return n.current.api()}),[]),a.createElement(f.Provider,{value:n.current},t.children)}));k.displayName="ChartContainer";var C=(0,a.forwardRef)((function(t,e){var n=(0,a.useContext)(f),r=(0,a.useRef)({api:function(){if(!this._api){t.children;var e=t.data,r=t.type,a=(0,i.Z)(t,u);this._api="line"===r?n.api().addLineSeries(a):n.api().addAreaSeries(a),this._api.setData(e)}return this._api},free:function(){this._api&&n.free()}});return(0,a.useLayoutEffect)((function(){var t=r.current;return t.api(),function(){return t.free()}}),[]),(0,a.useLayoutEffect)((function(){var e=r.current,n=(t.chilren,t.data,(0,i.Z)(t,d));e.api().applyOptions(n)})),(0,a.useImperativeHandle)(e,(function(){return r.current.api()}),[]),a.createElement(f.Provider,{value:r.current},t.children)}));C.displayName="Series";var b=n(5804),y=["components"],x={sidebar_label:"Advanced example",hide_table_of_contents:!0},N="React - Advanced example",R={unversionedId:"tutorials/react/advanced",id:"tutorials/react/advanced",title:"React - Advanced example",description:"The following describes a more complex scenario where a user could imagine splitting the responsibilities of the chart between components.",source:"@site/docs/tutorials/react/02-advanced.mdx",sourceDirName:"tutorials/react",slug:"/tutorials/react/advanced",permalink:"/lightweight-charts/docs/tutorials/react/advanced",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_label:"Advanced example",hide_table_of_contents:!0},sidebar:"tutorialsSidebar",previous:{title:"Simple example",permalink:"/lightweight-charts/docs/tutorials/react/simple"}},S=[],E={toc:S};function _(t){var e=t.components,n=(0,i.Z)(t,y);return(0,o.kt)("wrapper",(0,r.Z)({},E,n,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"react---advanced-example"},"React - Advanced example"),(0,o.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"The following describes a more complex scenario where a user could imagine splitting the responsibilities of the chart between components."),(0,o.kt)("p",{parentName:"div"},"If you want to consult a simpler approach please consult this ",(0,o.kt)("a",{parentName:"p",href:"./simple"},"example"),"."))),(0,o.kt)("div",{className:"admonition admonition-warning alert alert--danger"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))),"warning")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"By following the steps below we assume you're familiar with Lightweight Charts, how to set up a project using it and how to render a chart."),(0,o.kt)("p",{parentName:"div"},"If not, please follow this ",(0,o.kt)("a",{parentName:"p",href:"./simple"},"guide"),"."))),(0,o.kt)("p",null,"If you're familiar with Lightweight Charts you probably already know that a ",(0,o.kt)("em",{parentName:"p"},"Chart")," is a container that can contain one or more ",(0,o.kt)("a",{parentName:"p",href:"/lightweight-charts/docs/series-types"},(0,o.kt)("em",{parentName:"a"},"Series")),".\nEach ",(0,o.kt)("em",{parentName:"p"},"Series")," has its own options (for instance ",(0,o.kt)("a",{parentName:"p",href:"/lightweight-charts/docs/api/interfaces/AreaStyleOptions"},"AreaStyleOptions"),", ",(0,o.kt)("a",{parentName:"p",href:"/lightweight-charts/docs/api/interfaces/LineStyleOptions"},"LineStyleOptions"),", etc) in addition to ",(0,o.kt)("a",{parentName:"p",href:"/lightweight-charts/docs/price-scale"},"price")," and/or ",(0,o.kt)("a",{parentName:"p",href:"/lightweight-charts/docs/time-scale"},"time")," scale."),(0,o.kt)("p",null,"Based on this principle, one could easily imagine having a main component ",(0,o.kt)("em",{parentName:"p"},"Chart")," that could have some ",(0,o.kt)("em",{parentName:"p"},"Series")," children that could themselves have other children and so on.\nTherefore the structure could become something like"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"<Chart component>\n    <Series component 1>\n        <child component />\n    </Series component 1>\n    <Series component n>\n        <child component />\n    </Series component n>\n</Chart component>\n")),(0,o.kt)("p",null,"Even though it's possible to create a Chart without a Series, the complexity arises when another component wants to interact with any of its siblings/parent, like updating a series by adding more data or resizing the chart itself."),(0,o.kt)("p",null,"Given this tutorial is about React this is how we are going to define components relying on React ",(0,o.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/hooks-intro.html"},"Hooks")," and ",(0,o.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/composition-vs-inheritance.html"},"composition"),"."),(0,o.kt)("p",null,"However, one drawback with the way React and its hooks like ",(0,o.kt)("em",{parentName:"p"},"useEffect")," ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react/issues/16728"},"work")," in a parent/children implementation is that their respective hooks are called in a bottom-up order for instanciation but top-to-bottom when it comes to clean-up."),(0,o.kt)("p",null,"The following skeleton illustrates the mechanism."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import React, { useEffect } from 'react';\n\nexport const ParentComponent = () => {\n    // this effect will be triggered in position 3\n    useEffect(() =>\n        () => {\n            // this clean up will be triggered in position 1\n        }\n    , []);\n\n    // this effect will be triggered in position 4\n    useEffect(() =>\n        () => {\n            // this clean up will be triggered in position 2\n        }\n    , []);\n\n    // The parent will then return Following bit is to propagate all props & internalRef object down to children\n    return (\n        <ChildComponent />\n    );\n};\nParentComponent.displayName = 'ParentComponent';\n\nexport const ChildComponent = () => {\n    // this effect will be triggered in position 1\n    useEffect(() =>\n        () => {\n            // this clean up will be triggered in position 3\n        }\n    , []);\n\n    // this effect will be triggered in position 2\n    useEffect(() =>\n        () => {\n            // this clean up will be triggered in position 4\n        }\n    , []);\n\n    return (\n        <div />\n    );\n};\nChildComponent.displayName = 'ChildComponent';\n")),(0,o.kt)("p",null,"In essence, taking the example above, it means that a ",(0,o.kt)("inlineCode",{parentName:"p"},"ChildComponent")," (aka Series) would be created first whilst requiring a ",(0,o.kt)("inlineCode",{parentName:"p"},"ParentComponent")," (aka Chart)."),(0,o.kt)("p",null,"To achieve that, we will have to rely on a few hooks and take advantage of the way they work in addition to use ",(0,o.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/forwarding-refs.html"},"ref/forwardRef")," which is a technique to pass down properties from one component to its children."),(0,o.kt)("p",null,'In the end the "visible" structure and usage will be alike but internally it will be something like:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"<Chart component>\n    <ChartContainer>\n        <Series component 1>\n            <child component />\n        </Series component 1>\n        <Series component n>\n            <child component />\n        </Series component n>\n    </ChartContainer>\n</Chart component>\n")),(0,o.kt)("p",null,"where the ChartContainer's role would be needed to attach a DOMElement on which the chart will render.\nChartContainer will be responsible for creating a ",(0,o.kt)("strong",{parentName:"p"},"ref"),"erence that will hold functions to handle the lifecycle of the chart.\nThat reference will then be propagated down to the Series."),(0,o.kt)("p",null,"The same technique will be used within the Series component to handle this time the lifecycle of any Series along with adding data to be plotted."),(0,o.kt)("p",null,'Moreover those 2 "main" components will "expose" whatever functions the user wants from the internal reference object at a higher level, meaning once those references are accessible any other component would then be able to act on either the Chart or any Series.'),(0,o.kt)("p",null,"Here's a squeleton of what the final structure would be like:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import React, { useEffect, useImperativeHandle, useRef } from 'react';\n\nconst Context = createContext();\n\nexport const MainComponent = props =>\n    // Creates the first reference and instanciate a ParentComponent\n    (\n        <div ref={chartReference}>\n            <ParentComponent {...props} container={container} />\n        </div>\n    );\n\nexport const ParentComponent = forwardRef((props, ref) => {\n    const internalRef = useRef({\n        method1() {\n            // This function would be responsible for creating the chart for instance\n        },\n        methodn() {\n            // This function would be responsible for cleaning up the chart\n        },\n    });\n\n    // this effect will be triggered in position 3\n    useEffect(() =>\n        () => {\n            // this clean up will be triggered in position 1\n        }\n    , []);\n\n    // this effect will be triggered in position 4\n    useEffect(() =>\n        () => {\n            // this clean up will be triggered in position 2\n        }\n    , []);\n\n    useImperativeHandle(ref, () => {\n        // That's the hook responsible for exposing part of/entirety of internalRef\n    }, []);\n\n    // Following bit is to propagate all props & internalRef object down to children\n    return (\n        <Context.Provider value={internalRef.current}>\n            {props.children}\n        </Context.Provider>\n    );\n});\nParentComponent.displayName = 'ParentComponent';\n\nexport const ChildComponent = forwardRef((props, ref) => {\n    const internalRef = useRef({\n        method1() {\n            // This function would be responsible for creating a series\n        },\n        methodn() {\n            // This function would be responsible for removing it\n        },\n    });\n\n    // this effect will be triggered in position 1\n    useEffect(() =>\n        () => {\n            // this clean up will be triggered in position 3\n        }\n    , []);\n\n    // this effect will be triggered in position 2\n    useEffect(() =>\n        () => {\n            // this clean up will be triggered in position 4\n        }\n    , []);\n\n    useImperativeHandle(ref, () => {\n        // That's the hook responsible for exposing part of/entirety of internalRef\n    }, []);\n\n    // Following bit is to propagate all props & internalRef object down to children\n    return (\n        <Context.Provider value={internalRef.current}>\n            {props.children}\n        </Context.Provider>\n    );\n});\nChildComponent.displayName = 'ChildComponent';\n")),(0,o.kt)("p",null,"By considering all the above you could end up with Chart/Series components looking like the following"),(0,o.kt)(s.Z,{className:"language-jsx",mdxType:"CodeBlock"},"import { createChart } from 'lightweight-charts';\nimport React, {\n\tcreateContext,\n\tforwardRef,\n\tuseCallback,\n\tuseContext,\n\tuseEffect,\n\tuseImperativeHandle,\n\tuseLayoutEffect,\n\tuseRef,\n\tuseState,\n} from 'react';\n\nconst Context = createContext();\n\nconst initialData = [\n\t{ time: '2018-10-11', value: 52.89 },\n\t{ time: '2018-10-12', value: 51.65 },\n\t{ time: '2018-10-13', value: 51.56 },\n\t{ time: '2018-10-14', value: 50.19 },\n\t{ time: '2018-10-15', value: 51.86 },\n\t{ time: '2018-10-16', value: 51.25 },\n];\nconst currentDate = new Date(initialData[initialData.length - 1].time);\n\nexport const App = () => {\n\t// The following variables illustrate how a series could be updated.\n\tconst series1 = useRef(null);\n\tconst [started, setStarted] = useState(false);\n\n\t// The purpose of this effect is purely to show how a series could\n\t// be updated using the `reference` passed to the `Series` component.\n\tuseEffect(() => {\n\t\tif (series1.current === null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (started) {\n\t\t\tconst interval = setInterval(() => {\n\t\t\t\tcurrentDate.setDate(currentDate.getDate() + 1);\n\t\t\t\tconst next = {\n\t\t\t\t\ttime: currentDate.toISOString().slice(0, 10),\n\t\t\t\t\tvalue: 53 - 2 * Math.random(),\n\t\t\t\t};\n\t\t\t\tseries1.current.update(next);\n\t\t\t}, 1000);\n\t\t\treturn () => clearInterval(interval);\n\t\t}\n\t}, [started]);\n\n\treturn (\n\t\t<>\n\t\t\t<button type=\"button\" onClick={() => setStarted(current => !current)}>\n\t\t\t\t{started ? 'Stop updating' : 'Start updating series'}\n\t\t\t</button>\n\t\t\t<Chart>\n\t\t\t\t<Series\n\t\t\t\t\tref={series1}\n\t\t\t\t\ttype={'line'}\n\t\t\t\t\tdata={initialData}\n\t\t\t\t/>\n\t\t\t</Chart>\n\t\t</>\n\t);\n};\n\nexport function Chart(props) {\n\tconst [container, setContainer] = useState(false);\n\tconst handleRef = useCallback(ref => setContainer(ref), []);\n\treturn (\n\t\t<div ref={handleRef}>\n\t\t\t{container && <ChartContainer {...props} container={container} />}\n\t\t</div>\n\t);\n}\n\nexport const ChartContainer = forwardRef((props, ref) => {\n\tconst context = useRef({\n\t\tapi() {\n\t\t\tif (!this._api) {\n\t\t\t\tconst { children, container, ...rest } = props;\n\t\t\t\tthis._api = createChart(container, {\n\t\t\t\t\t...rest,\n\t\t\t\t\twidth: container.clientWidth,\n\t\t\t\t\theight: 300,\n\t\t\t\t});\n\t\t\t\tthis._api.timeScale().fitContent();\n\t\t\t}\n\t\t\treturn this._api;\n\t\t},\n\t\tfree() {\n\t\t\tif (this._api) {\n\t\t\t\tthis._api.remove();\n\t\t\t}\n\t\t},\n\t});\n\n\tuseLayoutEffect(() => {\n\t\tconst { children, container, ...rest } = props;\n\n\t\tconst currentRef = context.current;\n\t\tconst chart = currentRef.api();\n\n\t\tconst handleResize = () => {\n\t\t\tchart.applyOptions({\n\t\t\t\t...rest,\n\t\t\t\twidth: container.clientWidth,\n\t\t\t});\n\t\t};\n\n\t\twindow.addEventListener('resize', handleResize);\n\t\treturn () => {\n\t\t\twindow.removeEventListener('resize', handleResize);\n\t\t\tchart.remove();\n\t\t};\n\t}, []);\n\n\tuseLayoutEffect(() => {\n\t\tconst currentRef = context.current;\n\t\tcurrentRef.api();\n\t}, []);\n\n\tuseLayoutEffect(() => {\n\t\tconst currentRef = context.current;\n\t\tconst { children, container, ...rest } = props;\n\t\tcurrentRef.api().applyOptions(rest);\n\t}, []);\n\n\tuseImperativeHandle(ref, () => context.current.api(), []);\n\n\treturn (\n\t\t<Context.Provider value={context.current}>\n\t\t\t{props.children}\n\t\t</Context.Provider>\n\t);\n});\nChartContainer.displayName = 'ChartContainer';\n\nexport const Series = forwardRef((props, ref) => {\n\tconst parent = useContext(Context);\n\tconst context = useRef({\n\t\tapi() {\n\t\t\tif (!this._api) {\n\t\t\t\tconst { children, data, type, ...rest } = props;\n\t\t\t\tthis._api = type === 'line' ? parent.api().addLineSeries(rest) : parent.api().addAreaSeries(rest);\n\t\t\t\tthis._api.setData(data);\n\t\t\t}\n\t\t\treturn this._api;\n\t\t},\n\t\tfree() {\n\t\t\tif (this._api) {\n\t\t\t\tparent.free();\n\t\t\t}\n\t\t},\n\t});\n\n\tuseLayoutEffect(() => {\n\t\tconst currentRef = context.current;\n\t\tcurrentRef.api();\n\n\t\treturn () => currentRef.free();\n\t}, []);\n\n\tuseLayoutEffect(() => {\n\t\tconst currentRef = context.current;\n\t\tconst { chilren, data, ...rest } = props;\n\t\tcurrentRef.api().applyOptions(rest);\n\t});\n\n\tuseImperativeHandle(ref, () => context.current.api(), []);\n\n\treturn (\n\t\t<Context.Provider value={context.current}>\n\t\t\t{props.children}\n\t\t</Context.Provider>\n\t);\n});\nSeries.displayName = 'Series';\n"),(0,o.kt)("p",null,"The code above will produce a line series.\nGiven a ",(0,o.kt)("inlineCode",{parentName:"p"},"series1")," reference is created to be passed to the Series component you could reuse that object via ",(0,o.kt)("inlineCode",{parentName:"p"},"series1.current.[any function applicable on Series]"),"."),(0,o.kt)("p",null,"For instance and as shown below ",(0,o.kt)("inlineCode",{parentName:"p"},"series1.current.update(new data)")," is used upon clicking on the button."),(0,o.kt)("div",{className:b.Z.ChartContainer},(0,o.kt)(w,{mdxType:"App"})))}_.isMDXComponent=!0},5804:function(t,e){e.Z={ChartContainer:"ChartContainer_Hwvl"}}}]);